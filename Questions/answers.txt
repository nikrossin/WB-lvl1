Устные вопросы

Какой самый эффективный способ конкатенации строк?


Что такое интерфейсы, как они применяются в Go?
Это своего рода определение. Он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа.
Интерфейсы представляют абстракцию поведения других типов


Чем отличаются RWMutex от Mutex?
RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. Например, стандартный тип map.
Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах будут ждать, пока вы не отпустите мьютекс через .Unlock().
Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других горутинах блокируются, вызовы .RLock() спокойно проходят. Когда отпускаете мьютекс через .RUnlock(), ждущие вызовы .Lock() по-очереди могут забирать мьютекс на себя.
Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.


Чем отличаются буферизированные и не буферизированные каналы?
В буферизированном канале естть "емкость" для хранения значения отправленного в канал,
тем самым горутина не блокируется при записи, если есть место в буфере, и при чтение, если в канале хранится значение


Какой размер у структуры struct{}{}? 0


Есть ли в Go перегрузка методов или операторов?
Нет – это путанница


В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

В случае перебора порядок элементов мапы неизвестен и может быть всегда разным, в случае вывода переменной
хранящей карту – сортировка по ключу по возрастанию


В чем разница make и new?


Сколько существует способов задать переменную типа slice или map?
Var slice []int
Slice := int[]{}
Slice := make([]int)
Аналогично map


Что выведет данная программа и почему?


func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

1
1//указатель в функции локальный в этой функции

Что выведет данная программа и почему?


func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
Основной поток не завершится, поскольку передача waitGroup идет по значению

Что выведет данная программа и почему?


func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
0 // n внутри условного оператора локальна внутри блока


Что выведет данная программа и почему?


func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

{100, 2, 3, 4, 5}
переменные capacity len слайса передадутся по значение в функцию, а третий параметр слайса - есть указатель на массив, соответственно передастся указатель в функцию и на первой строчке кода успешно значение 0 элемента массива изменится, а значит и в обоих слайсах.
На второй строчке из-за значения cap = 5, в слайсе будет выделен новый массив с размерностью 10, а значит указатель на массив изменится, как и значение длинны слайса увеличится на 1.

Что выведет данная программа и почему?


func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

{b,b,a}
{a,a} // по тойже причине что и выше
