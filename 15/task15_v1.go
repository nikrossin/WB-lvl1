package main

import (
	"fmt"
)

var justString string

func createHugeString(length int) string {
	var str string
	for i := 0; i < 99; i++ {
		str += "s"
	}
	str += "ы"

	for i := 100; i < length; i++ {
		str += "s"
	}
	return str
}

func someFunc() {
	v := createHugeString(1 << 10)
	fmt.Println("Исходная строка:", cap([]byte(v)), len([]byte(v)))

	/*Строки аналогично слайсам в основе имеют указатель на массив, в случае со строками
	это массив байт,в отличие от слайса мы не можем менять значения элементов.
	При использование среза строки мы обращаемся к тому же массиву, что и у родтельской строки,
	однако это безопасно, поскольку строка неизменяема.Тем самым не нужно забивать память лишним массивом
	При преобразование строки в слайс байт, го позаботиться о копирование массива, тем самым безопасность строк
	от изменений сохраниться, к тому же cap слайса будет нужного размера (для длинны среза строки)
	*/
	justString = v[:100]
	fmt.Println("Срез исходной строки", justString)
	//преобразовав в слайс байт можно в этом убедиться (cap немного больше длинны строки)
	fmt.Println(cap([]byte(justString)), len([]byte(justString)))
	/*Однако строки это слайс байт, а данные могут быть и в unicode, к примеру киррилица
	Если использовать 1 и 2-ву байтовые символы, то при срезе (:100) мы можем либо срезать
	второй байт у символа, если он в конце, или же не вывести один однобайтовый элементв в конце
	Исправить эту ситуацию можно, преобразовав строку в слайс rune, тогда каждый элемент будет 2-х байтовый
	и можно спокойно применить срез, не потеряв данные
	*/
	/*преобразовав строку в слайс рун, мы можем смело брать срез, не боясь потери данных
	Однако для слайса рун у нас выделиться новый массив(копия строки), после преобразуем это в строку,
	соответсвенно создаться новый массив нужной длинны (в зависимости от среза.
	Касательно памяти у нас будет 2 побочных массива, в отличие от примера в задание, но сохраним данные.
	СЛайс рун не используется, поэтому им займется сборщик мусора
	*/
	justString = string([]rune(v)[:100])
	fmt.Println("Срез строки, преобразованной в руны", justString)
	fmt.Println(cap([]byte(justString)), len([]byte(justString)))
	//на этом примере видно, что у слайса рун capacity равно длинне исходной строки
	var strRune2 []rune
	strRune2 = []rune(v)[:100]
	fmt.Println(string(strRune2))
	fmt.Println(cap(strRune2), len(strRune2))

	//можно выделить слайс с cap сразу равным количеству символов
	strRune := make([]rune, 0, 100)
	strRune = append(strRune, []rune(v)[:100]...)
	fmt.Println("Срез строки с выделением cap", string(strRune))
	fmt.Println(cap(strRune), len(strRune))

}

func main() {
	someFunc()
	fmt.Println(justString)
}
